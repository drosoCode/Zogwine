// Code generated by sqlc. DO NOT EDIT.
// source: metadata.sql

package database

import (
	"context"
)

const getPerson = `-- name: GetPerson :one
SELECT id, name, gender, birth, death, overview, icon, knownFor, scraper_name, scraper_id, scraper_data, scraper_link, add_date, update_date, update_mode FROM person WHERE id = $1
`

func (q *Queries) GetPerson(ctx context.Context, id int64) (Person, error) {
	row := q.db.QueryRowContext(ctx, getPerson, id)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Gender,
		&i.Birth,
		&i.Death,
		&i.Overview,
		&i.Icon,
		&i.KnownFor,
		&i.ScraperName,
		&i.ScraperID,
		&i.ScraperData,
		&i.ScraperLink,
		&i.AddDate,
		&i.UpdateDate,
		&i.UpdateMode,
	)
	return i, err
}

const getRole = `-- name: GetRole :one
SELECT id, name, overview, icon, scraper_name, scraper_id, scraper_data, scraper_link, add_date, update_date, update_mode FROM role WHERE id = $1
`

func (q *Queries) GetRole(ctx context.Context, id int64) (Role, error) {
	row := q.db.QueryRowContext(ctx, getRole, id)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Overview,
		&i.Icon,
		&i.ScraperName,
		&i.ScraperID,
		&i.ScraperData,
		&i.ScraperLink,
		&i.AddDate,
		&i.UpdateDate,
		&i.UpdateMode,
	)
	return i, err
}

const getTag = `-- name: GetTag :one
SELECT id, name, value, icon FROM tag WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTag(ctx context.Context, id int64) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTag, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Value,
		&i.Icon,
	)
	return i, err
}

const listPersonByMedia = `-- name: ListPersonByMedia :many
SELECT id, name, gender, birth, death, overview, icon, knownFor, scraper_name, scraper_id, scraper_data, scraper_link, add_date, update_date, update_mode, id_person, media_type, media_data, id_role FROM person p INNER JOIN person_link l ON (p.id = l.id_person) WHERE l.media_type = $1 AND l.media_data = $2
`

type ListPersonByMediaParams struct {
	MediaType MediaType `json:"mediaType"`
	MediaData int64     `json:"mediaData"`
}

type ListPersonByMediaRow struct {
	ID          int64     `json:"id"`
	Name        string    `json:"name"`
	Gender      int64     `json:"gender"`
	Birth       int64     `json:"birth"`
	Death       int64     `json:"death"`
	Overview    string    `json:"overview"`
	Icon        string    `json:"icon"`
	KnownFor    string    `json:"knownFor"`
	ScraperName string    `json:"scraperName"`
	ScraperID   string    `json:"scraperID"`
	ScraperData string    `json:"scraperData"`
	ScraperLink string    `json:"scraperLink"`
	AddDate     int64     `json:"addDate"`
	UpdateDate  int64     `json:"updateDate"`
	UpdateMode  int64     `json:"updateMode"`
	IDPerson    int64     `json:"idPerson"`
	MediaType   MediaType `json:"mediaType"`
	MediaData   int64     `json:"mediaData"`
	IDRole      int64     `json:"idRole"`
}

func (q *Queries) ListPersonByMedia(ctx context.Context, arg ListPersonByMediaParams) ([]ListPersonByMediaRow, error) {
	rows, err := q.db.QueryContext(ctx, listPersonByMedia, arg.MediaType, arg.MediaData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPersonByMediaRow
	for rows.Next() {
		var i ListPersonByMediaRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Gender,
			&i.Birth,
			&i.Death,
			&i.Overview,
			&i.Icon,
			&i.KnownFor,
			&i.ScraperName,
			&i.ScraperID,
			&i.ScraperData,
			&i.ScraperLink,
			&i.AddDate,
			&i.UpdateDate,
			&i.UpdateMode,
			&i.IDPerson,
			&i.MediaType,
			&i.MediaData,
			&i.IDRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPersonByName = `-- name: ListPersonByName :many
SELECT id, name, gender, birth, death, overview, icon, knownFor, scraper_name, scraper_id, scraper_data, scraper_link, add_date, update_date, update_mode FROM person WHERE name LIKE $1
`

func (q *Queries) ListPersonByName(ctx context.Context, name string) ([]Person, error) {
	rows, err := q.db.QueryContext(ctx, listPersonByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Person
	for rows.Next() {
		var i Person
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Gender,
			&i.Birth,
			&i.Death,
			&i.Overview,
			&i.Icon,
			&i.KnownFor,
			&i.ScraperName,
			&i.ScraperID,
			&i.ScraperData,
			&i.ScraperLink,
			&i.AddDate,
			&i.UpdateDate,
			&i.UpdateMode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPersonByRole = `-- name: ListPersonByRole :many
SELECT id, name, gender, birth, death, overview, icon, knownFor, scraper_name, scraper_id, scraper_data, scraper_link, add_date, update_date, update_mode, id_person, media_type, media_data, id_role FROM person p INNER JOIN person_link l ON (p.id = l.id_person) WHERE l.id_role = $1
`

type ListPersonByRoleRow struct {
	ID          int64     `json:"id"`
	Name        string    `json:"name"`
	Gender      int64     `json:"gender"`
	Birth       int64     `json:"birth"`
	Death       int64     `json:"death"`
	Overview    string    `json:"overview"`
	Icon        string    `json:"icon"`
	KnownFor    string    `json:"knownFor"`
	ScraperName string    `json:"scraperName"`
	ScraperID   string    `json:"scraperID"`
	ScraperData string    `json:"scraperData"`
	ScraperLink string    `json:"scraperLink"`
	AddDate     int64     `json:"addDate"`
	UpdateDate  int64     `json:"updateDate"`
	UpdateMode  int64     `json:"updateMode"`
	IDPerson    int64     `json:"idPerson"`
	MediaType   MediaType `json:"mediaType"`
	MediaData   int64     `json:"mediaData"`
	IDRole      int64     `json:"idRole"`
}

func (q *Queries) ListPersonByRole(ctx context.Context, idRole int64) ([]ListPersonByRoleRow, error) {
	rows, err := q.db.QueryContext(ctx, listPersonByRole, idRole)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPersonByRoleRow
	for rows.Next() {
		var i ListPersonByRoleRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Gender,
			&i.Birth,
			&i.Death,
			&i.Overview,
			&i.Icon,
			&i.KnownFor,
			&i.ScraperName,
			&i.ScraperID,
			&i.ScraperData,
			&i.ScraperLink,
			&i.AddDate,
			&i.UpdateDate,
			&i.UpdateMode,
			&i.IDPerson,
			&i.MediaType,
			&i.MediaData,
			&i.IDRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoleByName = `-- name: ListRoleByName :many
SELECT id, name, overview, icon, scraper_name, scraper_id, scraper_data, scraper_link, add_date, update_date, update_mode FROM role WHERE name LIKE $1
`

func (q *Queries) ListRoleByName(ctx context.Context, name string) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, listRoleByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Overview,
			&i.Icon,
			&i.ScraperName,
			&i.ScraperID,
			&i.ScraperData,
			&i.ScraperLink,
			&i.AddDate,
			&i.UpdateDate,
			&i.UpdateMode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoleByPerson = `-- name: ListRoleByPerson :many
SELECT id, name, overview, icon, scraper_name, scraper_id, scraper_data, scraper_link, add_date, update_date, update_mode, id_person, media_type, media_data, id_role FROM role r INNER JOIN person_link l ON (r.id = l.id_role) WHERE l.id_person = $1
`

type ListRoleByPersonRow struct {
	ID          int64     `json:"id"`
	Name        string    `json:"name"`
	Overview    string    `json:"overview"`
	Icon        string    `json:"icon"`
	ScraperName string    `json:"scraperName"`
	ScraperID   string    `json:"scraperID"`
	ScraperData string    `json:"scraperData"`
	ScraperLink string    `json:"scraperLink"`
	AddDate     int64     `json:"addDate"`
	UpdateDate  int64     `json:"updateDate"`
	UpdateMode  int64     `json:"updateMode"`
	IDPerson    int64     `json:"idPerson"`
	MediaType   MediaType `json:"mediaType"`
	MediaData   int64     `json:"mediaData"`
	IDRole      int64     `json:"idRole"`
}

func (q *Queries) ListRoleByPerson(ctx context.Context, idPerson int64) ([]ListRoleByPersonRow, error) {
	rows, err := q.db.QueryContext(ctx, listRoleByPerson, idPerson)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRoleByPersonRow
	for rows.Next() {
		var i ListRoleByPersonRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Overview,
			&i.Icon,
			&i.ScraperName,
			&i.ScraperID,
			&i.ScraperData,
			&i.ScraperLink,
			&i.AddDate,
			&i.UpdateDate,
			&i.UpdateMode,
			&i.IDPerson,
			&i.MediaType,
			&i.MediaData,
			&i.IDRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagByCatg = `-- name: ListTagByCatg :many
SELECT id, name, value, icon FROM tag WHERE name = $1 LIMIT 1
`

func (q *Queries) ListTagByCatg(ctx context.Context, name string) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagByCatg, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Value,
			&i.Icon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagByMedia = `-- name: ListTagByMedia :many
SELECT id, name, value, icon, id_tag, media_type, media_data FROM tag t INNER JOIN tag_link l ON (t.id = l.id_tag) WHERE l.media_type = $1 AND l.media_data = $2
`

type ListTagByMediaParams struct {
	MediaType MediaType `json:"mediaType"`
	MediaData int64     `json:"mediaData"`
}

type ListTagByMediaRow struct {
	ID        int64     `json:"id"`
	Name      string    `json:"name"`
	Value     string    `json:"value"`
	Icon      string    `json:"icon"`
	IDTag     int64     `json:"idTag"`
	MediaType MediaType `json:"mediaType"`
	MediaData int64     `json:"mediaData"`
}

func (q *Queries) ListTagByMedia(ctx context.Context, arg ListTagByMediaParams) ([]ListTagByMediaRow, error) {
	rows, err := q.db.QueryContext(ctx, listTagByMedia, arg.MediaType, arg.MediaData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTagByMediaRow
	for rows.Next() {
		var i ListTagByMediaRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Value,
			&i.Icon,
			&i.IDTag,
			&i.MediaType,
			&i.MediaData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagCatg = `-- name: ListTagCatg :many
SELECT DISTINCT name FROM tag
`

func (q *Queries) ListTagCatg(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listTagCatg)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
