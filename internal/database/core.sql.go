// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: core.sql

package database

import (
	"context"
)

const getEpisodeStat = `-- name: GetEpisodeStat :one
SELECT 
    COUNT(*) AS watched_episode,
    SUM(watch_count) AS watched_episode_count,
    (
        SELECT COUNT(*)
        FROM episode
    ) AS episode_count,
    COALESCE((
        SELECT SUM(duration*watch_count) 
        FROM video_file v, episode e, status s 
        WHERE s.media_type = 'tvs_episode'
        AND v.media_type = 'tvs_episode'
        AND v.media_data = e.id
        AND s.media_data = e.id
        AND watch_count > 0 
        AND s.id_user = $1
    ), 0)::BIGINT AS episode_time
FROM status
WHERE watch_count > 0
    AND media_type = 'tvs_episode'
    AND id_user = $1
`

type GetEpisodeStatRow struct {
	WatchedEpisode      int64 `json:"watchedEpisode"`
	WatchedEpisodeCount int64 `json:"watchedEpisodeCount"`
	EpisodeCount        int64 `json:"episodeCount"`
	EpisodeTime         int64 `json:"episodeTime"`
}

func (q *Queries) GetEpisodeStat(ctx context.Context, idUser int64) (GetEpisodeStatRow, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeStat, idUser)
	var i GetEpisodeStatRow
	err := row.Scan(
		&i.WatchedEpisode,
		&i.WatchedEpisodeCount,
		&i.EpisodeCount,
		&i.EpisodeTime,
	)
	return i, err
}

const getMovieStat = `-- name: GetMovieStat :one
SELECT COUNT(*) AS watched_movie,
    SUM(watch_count) AS watched_movie_count,
    (
        SELECT COUNT(*)
        FROM movie
    ) AS movie_count,
    COALESCE((
        SELECT SUM(duration*watch_count) 
        FROM video_file v, movie m, status s 
        WHERE s.media_type = 'movie' 
        AND v.media_type = 'movie' 
        AND v.media_data = m.id
        AND s.media_data = m.id
        AND watch_count > 0 
        AND s.id_user = $1
    ),0)::BIGINT AS movie_time
FROM status
WHERE watch_count > 0
    AND media_type = 'movie'
    AND id_user = $1
`

type GetMovieStatRow struct {
	WatchedMovie      int64 `json:"watchedMovie"`
	WatchedMovieCount int64 `json:"watchedMovieCount"`
	MovieCount        int64 `json:"movieCount"`
	MovieTime         int64 `json:"movieTime"`
}

func (q *Queries) GetMovieStat(ctx context.Context, idUser int64) (GetMovieStatRow, error) {
	row := q.db.QueryRowContext(ctx, getMovieStat, idUser)
	var i GetMovieStatRow
	err := row.Scan(
		&i.WatchedMovie,
		&i.WatchedMovieCount,
		&i.MovieCount,
		&i.MovieTime,
	)
	return i, err
}

const getTVShowStat = `-- name: GetTVShowStat :one
SELECT (
        SELECT COUNT(*)
        FROM (
                SELECT COUNT(*) AS cnt
                FROM episode e1
                GROUP BY e1.id_show
                HAVING COUNT(*) = (
                        SELECT COUNT(*)
                        FROM status s
                        WHERE s.id_user = $1
                            AND s.media_type = 'tvs_episode'
                            AND s.watch_count > 0
                            AND s.media_data IN (
                                SELECT e2.id
                                FROM episode e2
                                WHERE e2.id_show = e1.id_show
                            )
                    )
            ) x
    ) AS watched_tvs,
    (
        SELECT COUNT(*)
        FROM tv_show
    ) AS tvs_count
`

type GetTVShowStatRow struct {
	WatchedTvs int64 `json:"watchedTvs"`
	TvsCount   int64 `json:"tvsCount"`
}

func (q *Queries) GetTVShowStat(ctx context.Context, idUser int64) (GetTVShowStatRow, error) {
	row := q.db.QueryRowContext(ctx, getTVShowStat, idUser)
	var i GetTVShowStatRow
	err := row.Scan(&i.WatchedTvs, &i.TvsCount)
	return i, err
}

const listNotCached = `-- name: ListNotCached :many
SELECT id, link, extension, cached FROM cache WHERE cached = false
`

func (q *Queries) ListNotCached(ctx context.Context) ([]Cache, error) {
	rows, err := q.db.QueryContext(ctx, listNotCached)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cache
	for rows.Next() {
		var i Cache
		if err := rows.Scan(
			&i.ID,
			&i.Link,
			&i.Extension,
			&i.Cached,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCache = `-- name: UpdateCache :exec
UPDATE cache SET extension = $1, cached = true WHERE id = $2
`

type UpdateCacheParams struct {
	Extension string `json:"extension"`
	ID        int64  `json:"id"`
}

func (q *Queries) UpdateCache(ctx context.Context, arg UpdateCacheParams) error {
	_, err := q.db.ExecContext(ctx, updateCache, arg.Extension, arg.ID)
	return err
}
