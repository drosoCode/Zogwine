// Code generated by sqlc. DO NOT EDIT.
// source: tvshow.sql

package database

import (
	"context"
)

const deleteShow = `-- name: DeleteShow :exec
DELETE FROM tv_show WHERE id = $1
`

func (q *Queries) DeleteShow(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteShow, id)
	return err
}

const deleteShowEpisode = `-- name: DeleteShowEpisode :exec
DELETE FROM episode WHERE id_show = $1
`

func (q *Queries) DeleteShowEpisode(ctx context.Context, idShow int64) error {
	_, err := q.db.ExecContext(ctx, deleteShowEpisode, idShow)
	return err
}

const deleteShowEpisodeByID = `-- name: DeleteShowEpisodeByID :exec
DELETE FROM episode WHERE id = $1
`

func (q *Queries) DeleteShowEpisodeByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteShowEpisodeByID, id)
	return err
}

const deleteShowEpisodeBySeason = `-- name: DeleteShowEpisodeBySeason :exec
DELETE FROM episode WHERE id_show = $1 AND season = $2
`

type DeleteShowEpisodeBySeasonParams struct {
	IDShow int64 `json:"idShow"`
	Season int64 `json:"season"`
}

func (q *Queries) DeleteShowEpisodeBySeason(ctx context.Context, arg DeleteShowEpisodeBySeasonParams) error {
	_, err := q.db.ExecContext(ctx, deleteShowEpisodeBySeason, arg.IDShow, arg.Season)
	return err
}

const deleteShowFile = `-- name: DeleteShowFile :exec
DELETE FROM video_file WHERE media_type = 'tvs_episode' AND media_data IN (SELECT id FROM episode WHERE id_show = $1)
`

func (q *Queries) DeleteShowFile(ctx context.Context, idShow int64) error {
	_, err := q.db.ExecContext(ctx, deleteShowFile, idShow)
	return err
}

const deleteShowFileByEpisode = `-- name: DeleteShowFileByEpisode :exec
DELETE FROM video_file WHERE media_type = 'tvs_episode' AND media_data = $1
`

func (q *Queries) DeleteShowFileByEpisode(ctx context.Context, mediaData int64) error {
	_, err := q.db.ExecContext(ctx, deleteShowFileByEpisode, mediaData)
	return err
}

const deleteShowFileBySeason = `-- name: DeleteShowFileBySeason :exec
DELETE FROM video_file WHERE media_type = 'tvs_episode' AND media_data IN (SELECT id FROM episode WHERE id_show = $1 AND season = $2)
`

type DeleteShowFileBySeasonParams struct {
	IDShow int64 `json:"idShow"`
	Season int64 `json:"season"`
}

func (q *Queries) DeleteShowFileBySeason(ctx context.Context, arg DeleteShowFileBySeasonParams) error {
	_, err := q.db.ExecContext(ctx, deleteShowFileBySeason, arg.IDShow, arg.Season)
	return err
}

const deleteShowSeason = `-- name: DeleteShowSeason :exec
DELETE FROM season WHERE id_show = $1
`

func (q *Queries) DeleteShowSeason(ctx context.Context, idShow int64) error {
	_, err := q.db.ExecContext(ctx, deleteShowSeason, idShow)
	return err
}

const deleteShowSeasonByNum = `-- name: DeleteShowSeasonByNum :exec
DELETE FROM season WHERE id_show = $1 AND season = $2
`

type DeleteShowSeasonByNumParams struct {
	IDShow int64 `json:"idShow"`
	Season int64 `json:"season"`
}

func (q *Queries) DeleteShowSeasonByNum(ctx context.Context, arg DeleteShowSeasonByNumParams) error {
	_, err := q.db.ExecContext(ctx, deleteShowSeasonByNum, arg.IDShow, arg.Season)
	return err
}

const deleteShowStatus = `-- name: DeleteShowStatus :exec
DELETE FROM status WHERE media_type = 'tvs_episode' AND media_data IN (SELECT id FROM episode WHERE id_show = $1)
`

func (q *Queries) DeleteShowStatus(ctx context.Context, idShow int64) error {
	_, err := q.db.ExecContext(ctx, deleteShowStatus, idShow)
	return err
}

const deleteShowStatusByEpisode = `-- name: DeleteShowStatusByEpisode :exec
DELETE FROM status WHERE media_type = 'tvs_episode' AND media_data = $1
`

func (q *Queries) DeleteShowStatusByEpisode(ctx context.Context, mediaData int64) error {
	_, err := q.db.ExecContext(ctx, deleteShowStatusByEpisode, mediaData)
	return err
}

const deleteShowStatusBySeason = `-- name: DeleteShowStatusBySeason :exec
DELETE FROM status WHERE media_type = 'tvs_episode' AND media_data IN (SELECT id FROM episode WHERE id_show = $1 AND season = $2)
`

type DeleteShowStatusBySeasonParams struct {
	IDShow int64 `json:"idShow"`
	Season int64 `json:"season"`
}

func (q *Queries) DeleteShowStatusBySeason(ctx context.Context, arg DeleteShowStatusBySeasonParams) error {
	_, err := q.db.ExecContext(ctx, deleteShowStatusBySeason, arg.IDShow, arg.Season)
	return err
}

const getShow = `-- name: GetShow :one
SELECT id, title, overview, 
FROMCACHE(icon) AS icon, 
FROMCACHE(fanart) AS fanart, 
FROMCACHE(trailer) AS trailer, 
rating, website, premiered, scraper_name, scraper_id, scraper_data, scraper_link, add_date, update_date, update_mode, id_lib, path,
(SELECT COUNT(*) FROM season WHERE id_show = t.id)::BIGINT AS season,
(SELECT COUNT(*) FROM episode WHERE id_show = t.id)::BIGINT AS episode,
(SELECT COUNT(*) FROM episode e LEFT JOIN status s ON (s.media_data = e.id)
    WHERE e.id = s.media_data AND s.media_type = 'tvs_episode' AND watch_count > 0  AND id_user = $1 and id_show = t.id) AS watched_episode
FROM tv_show t
WHERE t.id = $2
LIMIT 1
`

type GetShowParams struct {
	IDUser int64 `json:"idUser"`
	ID     int64 `json:"id"`
}

type GetShowRow struct {
	ID             int64  `json:"id"`
	Title          string `json:"title"`
	Overview       string `json:"overview"`
	Icon           string `json:"icon"`
	Fanart         string `json:"fanart"`
	Trailer        string `json:"trailer"`
	Rating         int64  `json:"rating"`
	Website        string `json:"website"`
	Premiered      int64  `json:"premiered"`
	ScraperName    string `json:"scraperName"`
	ScraperID      string `json:"scraperID"`
	ScraperData    string `json:"scraperData"`
	ScraperLink    string `json:"scraperLink"`
	AddDate        int64  `json:"addDate"`
	UpdateDate     int64  `json:"updateDate"`
	UpdateMode     int64  `json:"updateMode"`
	IDLib          int64  `json:"idLib"`
	Path           string `json:"path"`
	Season         int64  `json:"season"`
	Episode        int64  `json:"episode"`
	WatchedEpisode int64  `json:"watchedEpisode"`
}

func (q *Queries) GetShow(ctx context.Context, arg GetShowParams) (GetShowRow, error) {
	row := q.db.QueryRowContext(ctx, getShow, arg.IDUser, arg.ID)
	var i GetShowRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Overview,
		&i.Icon,
		&i.Fanart,
		&i.Trailer,
		&i.Rating,
		&i.Website,
		&i.Premiered,
		&i.ScraperName,
		&i.ScraperID,
		&i.ScraperData,
		&i.ScraperLink,
		&i.AddDate,
		&i.UpdateDate,
		&i.UpdateMode,
		&i.IDLib,
		&i.Path,
		&i.Season,
		&i.Episode,
		&i.WatchedEpisode,
	)
	return i, err
}

const getShowEpisode = `-- name: GetShowEpisode :one

SELECT e.id, title, overview, id_show, premiered, FROMCACHE(icon) AS icon, 
season, episode, rating, scraper_name, scraper_id, add_date, update_date,
COALESCE((SELECT value FROM filler_link WHERE media_type = 'tvs_episode' AND media_data = id), 0) AS filler,
COALESCE((SELECT watch_count FROM status WHERE media_data = e.id AND media_type = 'tvs_episode' AND id_user = $1),0)::BIGINT AS watch_count
FROM episode e
WHERE e.id = $2
LIMIT 1
`

type GetShowEpisodeParams struct {
	IDUser int64 `json:"idUser"`
	ID     int64 `json:"id"`
}

type GetShowEpisodeRow struct {
	ID          int64       `json:"id"`
	Title       string      `json:"title"`
	Overview    string      `json:"overview"`
	IDShow      int64       `json:"idShow"`
	Premiered   int64       `json:"premiered"`
	Icon        string      `json:"icon"`
	Season      int64       `json:"season"`
	Episode     int64       `json:"episode"`
	Rating      int64       `json:"rating"`
	ScraperName string      `json:"scraperName"`
	ScraperID   string      `json:"scraperID"`
	AddDate     int64       `json:"addDate"`
	UpdateDate  int64       `json:"updateDate"`
	Filler      interface{} `json:"filler"`
	WatchCount  int64       `json:"watchCount"`
}

//  =============================================== EPISODES ===============================================
func (q *Queries) GetShowEpisode(ctx context.Context, arg GetShowEpisodeParams) (GetShowEpisodeRow, error) {
	row := q.db.QueryRowContext(ctx, getShowEpisode, arg.IDUser, arg.ID)
	var i GetShowEpisodeRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Overview,
		&i.IDShow,
		&i.Premiered,
		&i.Icon,
		&i.Season,
		&i.Episode,
		&i.Rating,
		&i.ScraperName,
		&i.ScraperID,
		&i.AddDate,
		&i.UpdateDate,
		&i.Filler,
		&i.WatchCount,
	)
	return i, err
}

const getShowSeason = `-- name: GetShowSeason :one
SELECT s.id_show, title, overview, FROMCACHE(icon) AS icon, 
s.season, premiered, scraper_link, add_date, update_date,
(SELECT COUNT(*) FROM episode WHERE id_show = s.id_show AND season = s.season) AS episode,
(SELECT COUNT(watch_count) FROM status WHERE media_data IN  (SELECT id FROM episode e WHERE e.id_show = s.id_show AND season = s.season) AND media_type = 'tvs_episode'  AND watch_count > 0 AND id_user = $1)::BIGINT AS watched_episode
FROM season s
WHERE s.id_show = $2 AND s.season = $3
LIMIT 1
`

type GetShowSeasonParams struct {
	IDUser int64 `json:"idUser"`
	IDShow int64 `json:"idShow"`
	Season int64 `json:"season"`
}

type GetShowSeasonRow struct {
	IDShow         int64  `json:"idShow"`
	Title          string `json:"title"`
	Overview       string `json:"overview"`
	Icon           string `json:"icon"`
	Season         int64  `json:"season"`
	Premiered      int64  `json:"premiered"`
	ScraperLink    string `json:"scraperLink"`
	AddDate        int64  `json:"addDate"`
	UpdateDate     int64  `json:"updateDate"`
	Episode        int64  `json:"episode"`
	WatchedEpisode int64  `json:"watchedEpisode"`
}

func (q *Queries) GetShowSeason(ctx context.Context, arg GetShowSeasonParams) (GetShowSeasonRow, error) {
	row := q.db.QueryRowContext(ctx, getShowSeason, arg.IDUser, arg.IDShow, arg.Season)
	var i GetShowSeasonRow
	err := row.Scan(
		&i.IDShow,
		&i.Title,
		&i.Overview,
		&i.Icon,
		&i.Season,
		&i.Premiered,
		&i.ScraperLink,
		&i.AddDate,
		&i.UpdateDate,
		&i.Episode,
		&i.WatchedEpisode,
	)
	return i, err
}

const listShow = `-- name: ListShow :many

SELECT id, title, overview, 
FROMCACHE(icon) AS icon, 
FROMCACHE(fanart) AS fanart, 
FROMCACHE(trailer) AS trailer, 
rating, website, premiered, scraper_name, scraper_id, scraper_data, scraper_link, add_date, update_date, update_mode, id_lib, path,
(SELECT COUNT(*) FROM season WHERE id_show = t.id)::BIGINT AS season,
(SELECT COUNT(*) FROM episode WHERE id_show = t.id)::BIGINT AS episode,
(SELECT COUNT(*) FROM episode e LEFT JOIN status s ON (s.media_data = e.id)
    WHERE e.id = s.media_data AND s.media_type = 'tvs_episode' AND watch_count > 0  AND id_user = $1 and id_show = t.id) AS watched_episode
FROM tv_show t
ORDER BY title
`

type ListShowRow struct {
	ID             int64  `json:"id"`
	Title          string `json:"title"`
	Overview       string `json:"overview"`
	Icon           string `json:"icon"`
	Fanart         string `json:"fanart"`
	Trailer        string `json:"trailer"`
	Rating         int64  `json:"rating"`
	Website        string `json:"website"`
	Premiered      int64  `json:"premiered"`
	ScraperName    string `json:"scraperName"`
	ScraperID      string `json:"scraperID"`
	ScraperData    string `json:"scraperData"`
	ScraperLink    string `json:"scraperLink"`
	AddDate        int64  `json:"addDate"`
	UpdateDate     int64  `json:"updateDate"`
	UpdateMode     int64  `json:"updateMode"`
	IDLib          int64  `json:"idLib"`
	Path           string `json:"path"`
	Season         int64  `json:"season"`
	Episode        int64  `json:"episode"`
	WatchedEpisode int64  `json:"watchedEpisode"`
}

//  =============================================== TV SHOWS ===============================================
func (q *Queries) ListShow(ctx context.Context, idUser int64) ([]ListShowRow, error) {
	rows, err := q.db.QueryContext(ctx, listShow, idUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListShowRow
	for rows.Next() {
		var i ListShowRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Overview,
			&i.Icon,
			&i.Fanart,
			&i.Trailer,
			&i.Rating,
			&i.Website,
			&i.Premiered,
			&i.ScraperName,
			&i.ScraperID,
			&i.ScraperData,
			&i.ScraperLink,
			&i.AddDate,
			&i.UpdateDate,
			&i.UpdateMode,
			&i.IDLib,
			&i.Path,
			&i.Season,
			&i.Episode,
			&i.WatchedEpisode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShowEpisode = `-- name: ListShowEpisode :many
SELECT e.id, title, overview, id_show, premiered, FROMCACHE(icon) AS icon, 
season, episode, rating, scraper_name, scraper_id, add_date, update_date,
COALESCE((SELECT value FROM filler_link WHERE media_type = 'tvs_episode' AND media_data = id), 0) AS filler,
COALESCE((SELECT watch_count FROM status WHERE media_data = e.id AND media_type = 'tvs_episode' AND id_user = $1),0)::BIGINT AS watch_count
FROM episode e
WHERE id_show = $2
ORDER BY season, episode
`

type ListShowEpisodeParams struct {
	IDUser int64 `json:"idUser"`
	IDShow int64 `json:"idShow"`
}

type ListShowEpisodeRow struct {
	ID          int64       `json:"id"`
	Title       string      `json:"title"`
	Overview    string      `json:"overview"`
	IDShow      int64       `json:"idShow"`
	Premiered   int64       `json:"premiered"`
	Icon        string      `json:"icon"`
	Season      int64       `json:"season"`
	Episode     int64       `json:"episode"`
	Rating      int64       `json:"rating"`
	ScraperName string      `json:"scraperName"`
	ScraperID   string      `json:"scraperID"`
	AddDate     int64       `json:"addDate"`
	UpdateDate  int64       `json:"updateDate"`
	Filler      interface{} `json:"filler"`
	WatchCount  int64       `json:"watchCount"`
}

func (q *Queries) ListShowEpisode(ctx context.Context, arg ListShowEpisodeParams) ([]ListShowEpisodeRow, error) {
	rows, err := q.db.QueryContext(ctx, listShowEpisode, arg.IDUser, arg.IDShow)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListShowEpisodeRow
	for rows.Next() {
		var i ListShowEpisodeRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Overview,
			&i.IDShow,
			&i.Premiered,
			&i.Icon,
			&i.Season,
			&i.Episode,
			&i.Rating,
			&i.ScraperName,
			&i.ScraperID,
			&i.AddDate,
			&i.UpdateDate,
			&i.Filler,
			&i.WatchCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShowEpisodeBySeason = `-- name: ListShowEpisodeBySeason :many
SELECT e.id, title, overview, id_show, premiered, FROMCACHE(icon) AS icon, 
season, episode, rating, scraper_name, scraper_id, add_date, update_date,
COALESCE((SELECT value FROM filler_link WHERE media_type = 'tvs_episode' AND media_data = id), 0) AS filler,
COALESCE((SELECT watch_count FROM status WHERE media_data = e.id AND media_type = 'tvs_episode' AND id_user = $1),0)::BIGINT AS watch_count
FROM episode e
WHERE id_show = $2 AND season = $3
ORDER BY season, episode
`

type ListShowEpisodeBySeasonParams struct {
	IDUser int64 `json:"idUser"`
	IDShow int64 `json:"idShow"`
	Season int64 `json:"season"`
}

type ListShowEpisodeBySeasonRow struct {
	ID          int64       `json:"id"`
	Title       string      `json:"title"`
	Overview    string      `json:"overview"`
	IDShow      int64       `json:"idShow"`
	Premiered   int64       `json:"premiered"`
	Icon        string      `json:"icon"`
	Season      int64       `json:"season"`
	Episode     int64       `json:"episode"`
	Rating      int64       `json:"rating"`
	ScraperName string      `json:"scraperName"`
	ScraperID   string      `json:"scraperID"`
	AddDate     int64       `json:"addDate"`
	UpdateDate  int64       `json:"updateDate"`
	Filler      interface{} `json:"filler"`
	WatchCount  int64       `json:"watchCount"`
}

func (q *Queries) ListShowEpisodeBySeason(ctx context.Context, arg ListShowEpisodeBySeasonParams) ([]ListShowEpisodeBySeasonRow, error) {
	rows, err := q.db.QueryContext(ctx, listShowEpisodeBySeason, arg.IDUser, arg.IDShow, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListShowEpisodeBySeasonRow
	for rows.Next() {
		var i ListShowEpisodeBySeasonRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Overview,
			&i.IDShow,
			&i.Premiered,
			&i.Icon,
			&i.Season,
			&i.Episode,
			&i.Rating,
			&i.ScraperName,
			&i.ScraperID,
			&i.AddDate,
			&i.UpdateDate,
			&i.Filler,
			&i.WatchCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShowSeason = `-- name: ListShowSeason :many

SELECT id_show, title, overview, FROMCACHE(icon) AS icon, 
season, premiered, scraper_link, add_date, update_date,
(SELECT COUNT(*) FROM episode WHERE id_show = s.id_show AND season = s.season)::BIGINT AS episode,
(SELECT COUNT(watch_count) FROM status WHERE media_data IN (SELECT id FROM episode e WHERE e.id_show = s.id_show AND season = s.season) AND media_type = 'tvs_episode'  AND watch_count > 0 AND id_user = $1)::BIGINT AS watched_episode
FROM season s
WHERE s.id_show = $2
ORDER BY season
`

type ListShowSeasonParams struct {
	IDUser int64 `json:"idUser"`
	IDShow int64 `json:"idShow"`
}

type ListShowSeasonRow struct {
	IDShow         int64  `json:"idShow"`
	Title          string `json:"title"`
	Overview       string `json:"overview"`
	Icon           string `json:"icon"`
	Season         int64  `json:"season"`
	Premiered      int64  `json:"premiered"`
	ScraperLink    string `json:"scraperLink"`
	AddDate        int64  `json:"addDate"`
	UpdateDate     int64  `json:"updateDate"`
	Episode        int64  `json:"episode"`
	WatchedEpisode int64  `json:"watchedEpisode"`
}

//  =============================================== SEASONS ===============================================
func (q *Queries) ListShowSeason(ctx context.Context, arg ListShowSeasonParams) ([]ListShowSeasonRow, error) {
	rows, err := q.db.QueryContext(ctx, listShowSeason, arg.IDUser, arg.IDShow)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListShowSeasonRow
	for rows.Next() {
		var i ListShowSeasonRow
		if err := rows.Scan(
			&i.IDShow,
			&i.Title,
			&i.Overview,
			&i.Icon,
			&i.Season,
			&i.Premiered,
			&i.ScraperLink,
			&i.AddDate,
			&i.UpdateDate,
			&i.Episode,
			&i.WatchedEpisode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShow = `-- name: UpdateShow :exec
UPDATE tv_show t
SET title = CASE WHEN $3::TEXT != '' THEN $3::TEXT ELSE t.title END,
    overview = CASE WHEN $4::TEXT != '' THEN $4::TEXT ELSE t.overview END,
    icon = CASE WHEN $5::TEXT != '' THEN $5::TEXT ELSE t.icon END,
    fanart = CASE WHEN $6::TEXT != '' THEN $6::TEXT ELSE t.fanart END,
    website = CASE WHEN $7::TEXT != '' THEN $7::TEXT ELSE t.website END,
    trailer = CASE WHEN $8::TEXT != '' THEN $8::TEXT ELSE t.trailer END,
    rating = CASE WHEN $9::BIGINT > 0 THEN $9::BIGINT ELSE t.rating END,
    scraper_id = CASE WHEN $10::TEXT != '' THEN $10::TEXT ELSE t.scraper_id END,
    scraper_name = CASE WHEN $11::TEXT != '' THEN $11::TEXT ELSE t.scraper_name END,
    scraper_data = CASE WHEN $12::TEXT != '' THEN $12::TEXT ELSE t.scraper_data END,
    scraper_link = CASE WHEN $13::TEXT != '' THEN $13::TEXT ELSE t.scraper_link END,
    path = CASE WHEN $14::TEXT != '' THEN $14::TEXT ELSE t.path END,
    id_lib = CASE WHEN $15::BIGINT > 0 THEN $15::BIGINT ELSE t.id_lib END,
    update_mode = CASE WHEN $16::BIGINT > 0 THEN $16::BIGINT ELSE t.update_mode END,
    premiered = CASE WHEN $17::BIGINT > 0 THEN $17::BIGINT ELSE t.premiered END,
    update_date = $2
WHERE id = $1
`

type UpdateShowParams struct {
	ID          int64  `json:"id"`
	UpdateDate  int64  `json:"updateDate"`
	Title       string `json:"title"`
	Overview    string `json:"overview"`
	Icon        string `json:"icon"`
	Fanart      string `json:"fanart"`
	Website     string `json:"website"`
	Trailer     string `json:"trailer"`
	Rating      int64  `json:"rating"`
	ScraperID   string `json:"scraperID"`
	ScraperName string `json:"scraperName"`
	ScraperData string `json:"scraperData"`
	ScraperLink string `json:"scraperLink"`
	Path        string `json:"path"`
	IDLib       int64  `json:"idLib"`
	UpdateMode  int64  `json:"updateMode"`
	Premiered   int64  `json:"premiered"`
}

func (q *Queries) UpdateShow(ctx context.Context, arg UpdateShowParams) error {
	_, err := q.db.ExecContext(ctx, updateShow,
		arg.ID,
		arg.UpdateDate,
		arg.Title,
		arg.Overview,
		arg.Icon,
		arg.Fanart,
		arg.Website,
		arg.Trailer,
		arg.Rating,
		arg.ScraperID,
		arg.ScraperName,
		arg.ScraperData,
		arg.ScraperLink,
		arg.Path,
		arg.IDLib,
		arg.UpdateMode,
		arg.Premiered,
	)
	return err
}

const updateShowEpisode = `-- name: UpdateShowEpisode :exec
UPDATE episode t
SET title = CASE WHEN $3::TEXT != '' THEN $3::TEXT ELSE t.title END,
    overview = CASE WHEN $4::TEXT != '' THEN $4::TEXT ELSE t.overview END,
    icon = CASE WHEN $5::TEXT != '' THEN $5::TEXT ELSE t.icon END,
    rating = CASE WHEN $6::BIGINT > 0 THEN $6::BIGINT ELSE t.rating END,
    season = CASE WHEN $7::BIGINT > 0 THEN $7::BIGINT ELSE t.season END,
    episode = CASE WHEN $8::BIGINT > 0 THEN $8::BIGINT ELSE t.episode END,
    scraper_id = CASE WHEN $9::TEXT != '' THEN $9::TEXT ELSE t.scraper_id END,
    scraper_name = CASE WHEN $10::TEXT != '' THEN $10::TEXT ELSE t.scraper_name END,
    scraper_data = CASE WHEN $11::TEXT != '' THEN $11::TEXT ELSE t.scraper_data END,
    scraper_link = CASE WHEN $12::TEXT != '' THEN $12::TEXT ELSE t.scraper_link END,
    update_mode = CASE WHEN $13::BIGINT > 0 THEN $13::BIGINT ELSE t.update_mode END,
    premiered = CASE WHEN $14::BIGINT > 0 THEN $14::BIGINT ELSE t.premiered END,
    update_date = $2
WHERE id = $1
`

type UpdateShowEpisodeParams struct {
	ID          int64  `json:"id"`
	UpdateDate  int64  `json:"updateDate"`
	Title       string `json:"title"`
	Overview    string `json:"overview"`
	Icon        string `json:"icon"`
	Rating      int64  `json:"rating"`
	Season      int64  `json:"season"`
	Episode     int64  `json:"episode"`
	ScraperID   string `json:"scraperID"`
	ScraperName string `json:"scraperName"`
	ScraperData string `json:"scraperData"`
	ScraperLink string `json:"scraperLink"`
	UpdateMode  int64  `json:"updateMode"`
	Premiered   int64  `json:"premiered"`
}

func (q *Queries) UpdateShowEpisode(ctx context.Context, arg UpdateShowEpisodeParams) error {
	_, err := q.db.ExecContext(ctx, updateShowEpisode,
		arg.ID,
		arg.UpdateDate,
		arg.Title,
		arg.Overview,
		arg.Icon,
		arg.Rating,
		arg.Season,
		arg.Episode,
		arg.ScraperID,
		arg.ScraperName,
		arg.ScraperData,
		arg.ScraperLink,
		arg.UpdateMode,
		arg.Premiered,
	)
	return err
}

const updateShowIDLib = `-- name: UpdateShowIDLib :exec
UPDATE video_file SET id_lib = $1 WHERE media_type = 'tvs_episode' AND media_data IN (SELECT e.id FROM episode e WHERE id_show = $2)
`

type UpdateShowIDLibParams struct {
	IDLib  int64 `json:"idLib"`
	IDShow int64 `json:"idShow"`
}

func (q *Queries) UpdateShowIDLib(ctx context.Context, arg UpdateShowIDLibParams) error {
	_, err := q.db.ExecContext(ctx, updateShowIDLib, arg.IDLib, arg.IDShow)
	return err
}

const updateShowPath = `-- name: UpdateShowPath :exec
UPDATE video_file SET path = REGEXP_REPLACE(path, CONCAT('^', (SELECT path FROM tv_show t WHERE t.id = $1)), $2) WHERE media_type = 'tvs_episode' AND media_data IN (SELECT e.id FROM episode e WHERE id_show = $1)
`

type UpdateShowPathParams struct {
	ID            int64  `json:"id"`
	RegexpReplace string `json:"regexpReplace"`
}

func (q *Queries) UpdateShowPath(ctx context.Context, arg UpdateShowPathParams) error {
	_, err := q.db.ExecContext(ctx, updateShowPath, arg.ID, arg.RegexpReplace)
	return err
}

const updateShowSeason = `-- name: UpdateShowSeason :exec
UPDATE season t
SET title = CASE WHEN $4::TEXT != '' THEN $4::TEXT ELSE t.title END,
    overview = CASE WHEN $5::TEXT != '' THEN $5::TEXT ELSE t.overview END,
    icon = CASE WHEN $6::TEXT != '' THEN $6::TEXT ELSE t.icon END,
    fanart = CASE WHEN $7::TEXT != '' THEN $7::TEXT ELSE t.fanart END,
    rating = CASE WHEN $8::BIGINT > 0 THEN $8::BIGINT ELSE t.rating END,
    season = CASE WHEN $9::BIGINT > 0 THEN $9::BIGINT ELSE t.season END,
    scraper_link = CASE WHEN $10::TEXT != '' THEN $10::TEXT ELSE t.scraper_link END,
    update_mode = CASE WHEN $11::BIGINT > 0 THEN $11::BIGINT ELSE t.update_mode END,
    premiered = CASE WHEN $12::BIGINT > 0 THEN $12::BIGINT ELSE t.premiered END,
    update_date = $3
WHERE id_show = $1 AND season = $2
`

type UpdateShowSeasonParams struct {
	IDShow      int64  `json:"idShow"`
	Season      int64  `json:"season"`
	UpdateDate  int64  `json:"updateDate"`
	Title       string `json:"title"`
	Overview    string `json:"overview"`
	Icon        string `json:"icon"`
	Fanart      string `json:"fanart"`
	Rating      int64  `json:"rating"`
	Season_2    int64  `json:"season2"`
	ScraperLink string `json:"scraperLink"`
	UpdateMode  int64  `json:"updateMode"`
	Premiered   int64  `json:"premiered"`
}

func (q *Queries) UpdateShowSeason(ctx context.Context, arg UpdateShowSeasonParams) error {
	_, err := q.db.ExecContext(ctx, updateShowSeason,
		arg.IDShow,
		arg.Season,
		arg.UpdateDate,
		arg.Title,
		arg.Overview,
		arg.Icon,
		arg.Fanart,
		arg.Rating,
		arg.Season_2,
		arg.ScraperLink,
		arg.UpdateMode,
		arg.Premiered,
	)
	return err
}
