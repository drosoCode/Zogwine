// Code generated by sqlc. DO NOT EDIT.
// source: tvshow.sql

package database

import (
	"context"
	"time"
)

const deleteShow = `-- name: DeleteShow :exec
DELETE FROM tv_show WHERE id = $1
`

func (q *Queries) DeleteShow(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteShow, id)
	return err
}

const getEpisode = `-- name: GetEpisode :one

SELECT e.id, title, overview, id_show, CONCAT('/api/core/image/',icon)::TEXT AS icon, 
season, episode, rating, scraper_name, scraper_id, add_date, update_date,
(SELECT value FROM filler_link WHERE media_type = 'tvs_episode' AND media_data = id) AS filler,
(SELECT watch_count FROM status WHERE media_data = e.id AND media_type = 'tvs_episode' AND id_user = $1)::BIGINT AS watch_count
FROM episode e
WHERE e.id = $2
LIMIT 1
`

type GetEpisodeParams struct {
	IDUser int64 `json:"idUser"`
	ID     int64 `json:"id"`
}

type GetEpisodeRow struct {
	ID          int64     `json:"id"`
	Title       string    `json:"title"`
	Overview    string    `json:"overview"`
	IDShow      int64     `json:"idShow"`
	Icon        string    `json:"icon"`
	Season      int64     `json:"season"`
	Episode     int64     `json:"episode"`
	Rating      float32   `json:"rating"`
	ScraperName string    `json:"scraperName"`
	ScraperID   string    `json:"scraperID"`
	AddDate     time.Time `json:"addDate"`
	UpdateDate  time.Time `json:"updateDate"`
	Filler      int64     `json:"filler"`
	WatchCount  int64     `json:"watchCount"`
}

//  =============================================== EPISODES ===============================================
func (q *Queries) GetEpisode(ctx context.Context, arg GetEpisodeParams) (GetEpisodeRow, error) {
	row := q.db.QueryRowContext(ctx, getEpisode, arg.IDUser, arg.ID)
	var i GetEpisodeRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Overview,
		&i.IDShow,
		&i.Icon,
		&i.Season,
		&i.Episode,
		&i.Rating,
		&i.ScraperName,
		&i.ScraperID,
		&i.AddDate,
		&i.UpdateDate,
		&i.Filler,
		&i.WatchCount,
	)
	return i, err
}

const getSeason = `-- name: GetSeason :one
SELECT s.id_show, title, overview, CONCAT('/api/core/image/',icon)::TEXT AS icon, 
s.season, premiered, scraper_link, add_date, update_date,
(SELECT COUNT(*) FROM episode WHERE id_show = s.id_show AND season = s.season) AS episode,
(SELECT COUNT(watch_count) FROM status WHERE media_data IN (SELECT id FROM episode WHERE id_show = s.id AND season = s.season) AND media_type = 'tvs_episode'  AND watch_count > 0 AND id_user = $1)::BIGINT AS watchedEpisodes
FROM season s
WHERE s.id_show = $2 AND s.season = $3
LIMIT 1
`

type GetSeasonParams struct {
	IDUser int64 `json:"idUser"`
	IDShow int64 `json:"idShow"`
	Season int64 `json:"season"`
}

type GetSeasonRow struct {
	IDShow          int64     `json:"idShow"`
	Title           string    `json:"title"`
	Overview        string    `json:"overview"`
	Icon            string    `json:"icon"`
	Season          int64     `json:"season"`
	Premiered       time.Time `json:"premiered"`
	ScraperLink     string    `json:"scraperLink"`
	AddDate         time.Time `json:"addDate"`
	UpdateDate      time.Time `json:"updateDate"`
	Episode         int64     `json:"episode"`
	Watchedepisodes int64     `json:"watchedepisodes"`
}

func (q *Queries) GetSeason(ctx context.Context, arg GetSeasonParams) (GetSeasonRow, error) {
	row := q.db.QueryRowContext(ctx, getSeason, arg.IDUser, arg.IDShow, arg.Season)
	var i GetSeasonRow
	err := row.Scan(
		&i.IDShow,
		&i.Title,
		&i.Overview,
		&i.Icon,
		&i.Season,
		&i.Premiered,
		&i.ScraperLink,
		&i.AddDate,
		&i.UpdateDate,
		&i.Episode,
		&i.Watchedepisodes,
	)
	return i, err
}

const getShow = `-- name: GetShow :one
SELECT id, title, overview, 
CONCAT('/api/core/image/',icon)::TEXT AS icon, 
CONCAT('/api/core/image/',fanart)::TEXT AS fanart, 
rating, premiered, scraper_name, scraper_id, scraper_data, scraper_link, add_date, update_date, update_mode, id_lib, path,
(SELECT COUNT(*) FROM season WHERE id_show = t.id)::BIGINT AS season,
(SELECT COUNT(*) FROM episode WHERE id_show = t.id)::BIGINT AS episode,
(SELECT COUNT(*) FROM episode e LEFT JOIN status s ON (s.media_data = e.id)
    WHERE e.id = s.media_data AND s.media_type = 'tvs_episode' AND watch_count > 0  AND id_user = $1 and id_show = t.id) AS watched_episode
FROM tv_show t
WHERE t.id = $2
LIMIT 1
`

type GetShowParams struct {
	IDUser int64 `json:"idUser"`
	ID     int64 `json:"id"`
}

type GetShowRow struct {
	ID             int64     `json:"id"`
	Title          string    `json:"title"`
	Overview       string    `json:"overview"`
	Icon           string    `json:"icon"`
	Fanart         string    `json:"fanart"`
	Rating         float32   `json:"rating"`
	Premiered      time.Time `json:"premiered"`
	ScraperName    string    `json:"scraperName"`
	ScraperID      string    `json:"scraperID"`
	ScraperData    string    `json:"scraperData"`
	ScraperLink    string    `json:"scraperLink"`
	AddDate        time.Time `json:"addDate"`
	UpdateDate     time.Time `json:"updateDate"`
	UpdateMode     int64     `json:"updateMode"`
	IDLib          int64     `json:"idLib"`
	Path           string    `json:"path"`
	Season         int64     `json:"season"`
	Episode        int64     `json:"episode"`
	WatchedEpisode int64     `json:"watchedEpisode"`
}

func (q *Queries) GetShow(ctx context.Context, arg GetShowParams) (GetShowRow, error) {
	row := q.db.QueryRowContext(ctx, getShow, arg.IDUser, arg.ID)
	var i GetShowRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Overview,
		&i.Icon,
		&i.Fanart,
		&i.Rating,
		&i.Premiered,
		&i.ScraperName,
		&i.ScraperID,
		&i.ScraperData,
		&i.ScraperLink,
		&i.AddDate,
		&i.UpdateDate,
		&i.UpdateMode,
		&i.IDLib,
		&i.Path,
		&i.Season,
		&i.Episode,
		&i.WatchedEpisode,
	)
	return i, err
}

const listEpisodeBySeason = `-- name: ListEpisodeBySeason :many
SELECT e.id, title, overview, id_show, CONCAT('/api/core/image/',icon)::TEXT AS icon, 
season, episode, rating, scraper_name, scraper_id, add_date, update_date,
(SELECT value FROM filler_link WHERE media_type = 'tvs_episode' AND media_data = id) AS filler,
(SELECT watch_count FROM status WHERE media_data = e.id AND media_type = 'tvs_episode' AND id_user = $1)::BIGINT AS watch_count
FROM episode e
WHERE id_show = $2 AND season = $3
ORDER BY season, episode
`

type ListEpisodeBySeasonParams struct {
	IDUser int64 `json:"idUser"`
	IDShow int64 `json:"idShow"`
	Season int64 `json:"season"`
}

type ListEpisodeBySeasonRow struct {
	ID          int64     `json:"id"`
	Title       string    `json:"title"`
	Overview    string    `json:"overview"`
	IDShow      int64     `json:"idShow"`
	Icon        string    `json:"icon"`
	Season      int64     `json:"season"`
	Episode     int64     `json:"episode"`
	Rating      float32   `json:"rating"`
	ScraperName string    `json:"scraperName"`
	ScraperID   string    `json:"scraperID"`
	AddDate     time.Time `json:"addDate"`
	UpdateDate  time.Time `json:"updateDate"`
	Filler      int64     `json:"filler"`
	WatchCount  int64     `json:"watchCount"`
}

func (q *Queries) ListEpisodeBySeason(ctx context.Context, arg ListEpisodeBySeasonParams) ([]ListEpisodeBySeasonRow, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeBySeason, arg.IDUser, arg.IDShow, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEpisodeBySeasonRow
	for rows.Next() {
		var i ListEpisodeBySeasonRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Overview,
			&i.IDShow,
			&i.Icon,
			&i.Season,
			&i.Episode,
			&i.Rating,
			&i.ScraperName,
			&i.ScraperID,
			&i.AddDate,
			&i.UpdateDate,
			&i.Filler,
			&i.WatchCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeByShow = `-- name: ListEpisodeByShow :many
SELECT e.id, title, overview, id_show, CONCAT('/api/core/image/',icon)::TEXT AS icon, 
season, episode, rating, scraper_name, scraper_id, add_date, update_date,
(SELECT value FROM filler_link WHERE media_type = 'tvs_episode' AND media_data = id) AS filler,
(SELECT watch_count FROM status WHERE media_data = e.id AND media_type = 'tvs_episode' AND id_user = $1)::BIGINT AS watch_count
FROM episode e
WHERE id_show = $2
ORDER BY season, episode
`

type ListEpisodeByShowParams struct {
	IDUser int64 `json:"idUser"`
	IDShow int64 `json:"idShow"`
}

type ListEpisodeByShowRow struct {
	ID          int64     `json:"id"`
	Title       string    `json:"title"`
	Overview    string    `json:"overview"`
	IDShow      int64     `json:"idShow"`
	Icon        string    `json:"icon"`
	Season      int64     `json:"season"`
	Episode     int64     `json:"episode"`
	Rating      float32   `json:"rating"`
	ScraperName string    `json:"scraperName"`
	ScraperID   string    `json:"scraperID"`
	AddDate     time.Time `json:"addDate"`
	UpdateDate  time.Time `json:"updateDate"`
	Filler      int64     `json:"filler"`
	WatchCount  int64     `json:"watchCount"`
}

func (q *Queries) ListEpisodeByShow(ctx context.Context, arg ListEpisodeByShowParams) ([]ListEpisodeByShowRow, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeByShow, arg.IDUser, arg.IDShow)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEpisodeByShowRow
	for rows.Next() {
		var i ListEpisodeByShowRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Overview,
			&i.IDShow,
			&i.Icon,
			&i.Season,
			&i.Episode,
			&i.Rating,
			&i.ScraperName,
			&i.ScraperID,
			&i.AddDate,
			&i.UpdateDate,
			&i.Filler,
			&i.WatchCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeason = `-- name: ListSeason :many

SELECT id_show, title, overview, CONCAT('/api/core/image/',icon)::TEXT AS icon, 
season, premiered, scraper_link, add_date, update_date,
(SELECT COUNT(*) FROM episode WHERE id_show = s.id_show AND season = s.season)::BIGINT AS episode,
(SELECT COUNT(watch_count) FROM status WHERE media_data IN (SELECT id FROM episode WHERE id_show = s.id AND season = s.season) AND media_type = 'tvs_episode'  AND watch_count > 0 AND id_user = $1)::BIGINT AS watchedEpisodes
FROM season s
WHERE s.id_show = $2
ORDER BY season
`

type ListSeasonParams struct {
	IDUser int64 `json:"idUser"`
	IDShow int64 `json:"idShow"`
}

type ListSeasonRow struct {
	IDShow          int64     `json:"idShow"`
	Title           string    `json:"title"`
	Overview        string    `json:"overview"`
	Icon            string    `json:"icon"`
	Season          int64     `json:"season"`
	Premiered       time.Time `json:"premiered"`
	ScraperLink     string    `json:"scraperLink"`
	AddDate         time.Time `json:"addDate"`
	UpdateDate      time.Time `json:"updateDate"`
	Episode         int64     `json:"episode"`
	Watchedepisodes int64     `json:"watchedepisodes"`
}

//  =============================================== SEASONS ===============================================
func (q *Queries) ListSeason(ctx context.Context, arg ListSeasonParams) ([]ListSeasonRow, error) {
	rows, err := q.db.QueryContext(ctx, listSeason, arg.IDUser, arg.IDShow)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSeasonRow
	for rows.Next() {
		var i ListSeasonRow
		if err := rows.Scan(
			&i.IDShow,
			&i.Title,
			&i.Overview,
			&i.Icon,
			&i.Season,
			&i.Premiered,
			&i.ScraperLink,
			&i.AddDate,
			&i.UpdateDate,
			&i.Episode,
			&i.Watchedepisodes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShow = `-- name: ListShow :many

SELECT id, title, overview, 
CONCAT('/api/core/image/',icon)::TEXT AS icon, 
CONCAT('/api/core/image/',fanart)::TEXT AS fanart, 
rating, premiered, scraper_name, scraper_id, scraper_data, scraper_link, add_date, update_date, update_mode, id_lib, path,
(SELECT COUNT(*) FROM season WHERE id_show = t.id)::BIGINT AS season,
(SELECT COUNT(*) FROM episode WHERE id_show = t.id)::BIGINT AS episode,
(SELECT COUNT(*) FROM episode e LEFT JOIN status s ON (s.media_data = e.id)
    WHERE e.id = s.media_data AND s.media_type = 'tvs_episode' AND watch_count > 0  AND id_user = $1 and id_show = t.id) AS watched_episode
FROM tv_show t
ORDER BY title
`

type ListShowRow struct {
	ID             int64     `json:"id"`
	Title          string    `json:"title"`
	Overview       string    `json:"overview"`
	Icon           string    `json:"icon"`
	Fanart         string    `json:"fanart"`
	Rating         float32   `json:"rating"`
	Premiered      time.Time `json:"premiered"`
	ScraperName    string    `json:"scraperName"`
	ScraperID      string    `json:"scraperID"`
	ScraperData    string    `json:"scraperData"`
	ScraperLink    string    `json:"scraperLink"`
	AddDate        time.Time `json:"addDate"`
	UpdateDate     time.Time `json:"updateDate"`
	UpdateMode     int64     `json:"updateMode"`
	IDLib          int64     `json:"idLib"`
	Path           string    `json:"path"`
	Season         int64     `json:"season"`
	Episode        int64     `json:"episode"`
	WatchedEpisode int64     `json:"watchedEpisode"`
}

//  =============================================== TV SHOWS ===============================================
func (q *Queries) ListShow(ctx context.Context, idUser int64) ([]ListShowRow, error) {
	rows, err := q.db.QueryContext(ctx, listShow, idUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListShowRow
	for rows.Next() {
		var i ListShowRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Overview,
			&i.Icon,
			&i.Fanart,
			&i.Rating,
			&i.Premiered,
			&i.ScraperName,
			&i.ScraperID,
			&i.ScraperData,
			&i.ScraperLink,
			&i.AddDate,
			&i.UpdateDate,
			&i.UpdateMode,
			&i.IDLib,
			&i.Path,
			&i.Season,
			&i.Episode,
			&i.WatchedEpisode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShow = `-- name: UpdateShow :exec
UPDATE tv_show t
SET title = CASE WHEN $3::TEXT != '' THEN $3::TEXT ELSE t.title END,
    overview = CASE WHEN $4::TEXT != '' THEN $4::TEXT ELSE t.overview END,
    icon = CASE WHEN $5::TEXT != '' THEN $5::TEXT ELSE t.icon END,
    fanart = CASE WHEN $6::TEXT != '' THEN $6::TEXT ELSE t.fanart END,
    rating = CASE WHEN $7::BIGINT >= 0 THEN $7::TEXT ELSE t.rating END,
    scraper_id = CASE WHEN $8::TEXT != '' THEN $8::TEXT ELSE t.scraper_id END,
    scraper_name = CASE WHEN $9::TEXT != '' THEN $9::TEXT ELSE t.scraper_name END,
    scraper_data = CASE WHEN $10::TEXT != '' THEN $10::TEXT ELSE t.scraper_data END,
    scraper_link = CASE WHEN $11::TEXT != '' THEN $11::TEXT ELSE t.scraper_link END,
    path = CASE WHEN $12::TEXT != '' THEN $12::TEXT ELSE t.path END,
    icon = CASE WHEN $5::TEXT != '' THEN $5::TEXT ELSE t.icon END,
    id_lib = CASE WHEN $13::BIGINT >= 0 THEN $13::TEXT ELSE t.id_lib END,
    update_mode = CASE WHEN $14::BIGINT >= 0 THEN $14::TEXT ELSE t.update_mode END,
    premiered = CASE WHEN $15::TIMESTAMP > '0001-01-01 00:00:00' THEN $15::TEXT ELSE t.premiered END,
    update_date = $2
WHERE id = $1
`

type UpdateShowParams struct {
	ID          int64     `json:"id"`
	UpdateDate  time.Time `json:"updateDate"`
	Title       string    `json:"title"`
	Overview    string    `json:"overview"`
	Icon        string    `json:"icon"`
	Fanart      string    `json:"fanart"`
	Rating      int64     `json:"rating"`
	ScraperID   string    `json:"scraperID"`
	ScraperName string    `json:"scraperName"`
	ScraperData string    `json:"scraperData"`
	ScraperLink string    `json:"scraperLink"`
	Path        string    `json:"path"`
	IDLib       int64     `json:"idLib"`
	UpdateMode  int64     `json:"updateMode"`
	Premiered   time.Time `json:"premiered"`
}

func (q *Queries) UpdateShow(ctx context.Context, arg UpdateShowParams) error {
	_, err := q.db.ExecContext(ctx, updateShow,
		arg.ID,
		arg.UpdateDate,
		arg.Title,
		arg.Overview,
		arg.Icon,
		arg.Fanart,
		arg.Rating,
		arg.ScraperID,
		arg.ScraperName,
		arg.ScraperData,
		arg.ScraperLink,
		arg.Path,
		arg.IDLib,
		arg.UpdateMode,
		arg.Premiered,
	)
	return err
}
