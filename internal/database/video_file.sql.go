// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: video_file.sql

package database

import (
	"context"
	"encoding/json"
)

const addVideoFile = `-- name: AddVideoFile :one
INSERT INTO video_file (id_lib, media_type, media_data, "path", "format", duration, extension, video, audio, subtitle, size, hash, tmp, add_date, update_date) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) RETURNING id
`

type AddVideoFileParams struct {
	IDLib      int64           `json:"idLib"`
	MediaType  MediaType       `json:"mediaType"`
	MediaData  int64           `json:"mediaData"`
	Path       string          `json:"path"`
	Format     string          `json:"format"`
	Duration   float64         `json:"duration"`
	Extension  string          `json:"extension"`
	Video      json.RawMessage `json:"video"`
	Audio      json.RawMessage `json:"audio"`
	Subtitle   json.RawMessage `json:"subtitle"`
	Size       float64         `json:"size"`
	Hash       string          `json:"hash"`
	Tmp        bool            `json:"tmp"`
	AddDate    int64           `json:"addDate"`
	UpdateDate int64           `json:"updateDate"`
}

func (q *Queries) AddVideoFile(ctx context.Context, arg AddVideoFileParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addVideoFile,
		arg.IDLib,
		arg.MediaType,
		arg.MediaData,
		arg.Path,
		arg.Format,
		arg.Duration,
		arg.Extension,
		arg.Video,
		arg.Audio,
		arg.Subtitle,
		arg.Size,
		arg.Hash,
		arg.Tmp,
		arg.AddDate,
		arg.UpdateDate,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const checkVideoHash = `-- name: CheckVideoHash :one
SELECT COUNT(*) > 0 AS present FROM video_file WHERE hash = $1
`

func (q *Queries) CheckVideoHash(ctx context.Context, hash string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkVideoHash, hash)
	var present bool
	err := row.Scan(&present)
	return present, err
}

const getVideoFile = `-- name: GetVideoFile :one
SELECT id, id_lib, media_type, media_data, path, format, duration, extension, video, audio, subtitle, size, tmp, hash, add_date, update_date FROM video_file WHERE id = $1
`

func (q *Queries) GetVideoFile(ctx context.Context, id int64) (VideoFile, error) {
	row := q.db.QueryRowContext(ctx, getVideoFile, id)
	var i VideoFile
	err := row.Scan(
		&i.ID,
		&i.IDLib,
		&i.MediaType,
		&i.MediaData,
		&i.Path,
		&i.Format,
		&i.Duration,
		&i.Extension,
		&i.Video,
		&i.Audio,
		&i.Subtitle,
		&i.Size,
		&i.Tmp,
		&i.Hash,
		&i.AddDate,
		&i.UpdateDate,
	)
	return i, err
}

const getVideoFileFromMedia = `-- name: GetVideoFileFromMedia :one
SELECT id, id_lib, media_type, media_data, path, format, duration, extension, video, audio, subtitle, size, tmp, hash, add_date, update_date FROM video_file WHERE media_type = $1 AND media_data = $2 ORDER BY id OFFSET $3 LIMIT 1
`

type GetVideoFileFromMediaParams struct {
	MediaType MediaType `json:"mediaType"`
	MediaData int64     `json:"mediaData"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) GetVideoFileFromMedia(ctx context.Context, arg GetVideoFileFromMediaParams) (VideoFile, error) {
	row := q.db.QueryRowContext(ctx, getVideoFileFromMedia, arg.MediaType, arg.MediaData, arg.Offset)
	var i VideoFile
	err := row.Scan(
		&i.ID,
		&i.IDLib,
		&i.MediaType,
		&i.MediaData,
		&i.Path,
		&i.Format,
		&i.Duration,
		&i.Extension,
		&i.Video,
		&i.Audio,
		&i.Subtitle,
		&i.Size,
		&i.Tmp,
		&i.Hash,
		&i.AddDate,
		&i.UpdateDate,
	)
	return i, err
}

const getVideoFileFromPath = `-- name: GetVideoFileFromPath :one
SELECT id, id_lib, media_type, media_data, path, format, duration, extension, video, audio, subtitle, size, tmp, hash, add_date, update_date FROM video_file WHERE id_lib = $1 AND path = $2 LIMIT 1
`

type GetVideoFileFromPathParams struct {
	IDLib int64  `json:"idLib"`
	Path  string `json:"path"`
}

func (q *Queries) GetVideoFileFromPath(ctx context.Context, arg GetVideoFileFromPathParams) (VideoFile, error) {
	row := q.db.QueryRowContext(ctx, getVideoFileFromPath, arg.IDLib, arg.Path)
	var i VideoFile
	err := row.Scan(
		&i.ID,
		&i.IDLib,
		&i.MediaType,
		&i.MediaData,
		&i.Path,
		&i.Format,
		&i.Duration,
		&i.Extension,
		&i.Video,
		&i.Audio,
		&i.Subtitle,
		&i.Size,
		&i.Tmp,
		&i.Hash,
		&i.AddDate,
		&i.UpdateDate,
	)
	return i, err
}

const listVideoFileFromMedia = `-- name: ListVideoFileFromMedia :many
SELECT id, id_lib, media_type, media_data, path, format, duration, extension, video, audio, subtitle, size, tmp, hash, add_date, update_date FROM video_file WHERE media_type = $1 AND media_data = $2
`

type ListVideoFileFromMediaParams struct {
	MediaType MediaType `json:"mediaType"`
	MediaData int64     `json:"mediaData"`
}

func (q *Queries) ListVideoFileFromMedia(ctx context.Context, arg ListVideoFileFromMediaParams) ([]VideoFile, error) {
	rows, err := q.db.QueryContext(ctx, listVideoFileFromMedia, arg.MediaType, arg.MediaData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VideoFile
	for rows.Next() {
		var i VideoFile
		if err := rows.Scan(
			&i.ID,
			&i.IDLib,
			&i.MediaType,
			&i.MediaData,
			&i.Path,
			&i.Format,
			&i.Duration,
			&i.Extension,
			&i.Video,
			&i.Audio,
			&i.Subtitle,
			&i.Size,
			&i.Tmp,
			&i.Hash,
			&i.AddDate,
			&i.UpdateDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVideoFile = `-- name: UpdateVideoFile :exec
UPDATE video_file t
SET id_lib = CASE WHEN $3::TEXT != '' THEN $3::TEXT ELSE t.id_lib END,
    media_type = CASE WHEN $4::media_type != '' THEN $4::media_type ELSE t.media_type END,
    media_data = CASE WHEN $5::BIGINT > 0 THEN $5::BIGINT ELSE t.media_data END,
    path = CASE WHEN $6::TEXT != '' THEN $6::TEXT ELSE t.path END,
    format = CASE WHEN $7::TEXT != '' THEN $7::TEXT ELSE t.format END,
    duration = CASE WHEN $8::double precision > 0 THEN $8::double precision ELSE t.duration END,
    extension = CASE WHEN $9::TEXT != '' THEN $9::TEXT ELSE t.extension END,
    video = CASE WHEN $10::json != '' THEN $10::json ELSE t.video END,
    audio = CASE WHEN $11::json != '' THEN $11::json ELSE t.audio END,
    subtitle = CASE WHEN $12::json != '' THEN $12::json ELSE t.subtitle END,
    size = CASE WHEN $13::double precision > 0 THEN $13::double precision ELSE t.size END,
    hash = CASE WHEN $14::TEXT != '' THEN $14::TEXT ELSE t.hash END,
    update_date = $2
WHERE id = $1
`

type UpdateVideoFileParams struct {
	ID         int64           `json:"id"`
	UpdateDate int64           `json:"updateDate"`
	IDLib      string          `json:"idLib"`
	MediaType  MediaType       `json:"mediaType"`
	MediaData  int64           `json:"mediaData"`
	Path       string          `json:"path"`
	Format     string          `json:"format"`
	Duration   float64         `json:"duration"`
	Extension  string          `json:"extension"`
	Video      json.RawMessage `json:"video"`
	Audio      json.RawMessage `json:"audio"`
	Subtitle   json.RawMessage `json:"subtitle"`
	Size       float64         `json:"size"`
	Hash       string          `json:"hash"`
}

func (q *Queries) UpdateVideoFile(ctx context.Context, arg UpdateVideoFileParams) error {
	_, err := q.db.ExecContext(ctx, updateVideoFile,
		arg.ID,
		arg.UpdateDate,
		arg.IDLib,
		arg.MediaType,
		arg.MediaData,
		arg.Path,
		arg.Format,
		arg.Duration,
		arg.Extension,
		arg.Video,
		arg.Audio,
		arg.Subtitle,
		arg.Size,
		arg.Hash,
	)
	return err
}
